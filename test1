#grep for regular expressions - search for firewall dependencies like hostname or https
grep -Eo '(https?://)?([0-9]{1,3}\.){3}[0-9]{1,3}(:[0-9]+)?|([a-zA-Z0-9]+(\.[a-zA-Z0-9-]+)+)(:[0-9]+)?' flow.xml | sort | uniq
#
import xml.etree.ElementTree as ET

tree = ET.parse('flow.xml')
root = tree.getroot()

for elem in root.iter():
    if 'value' in elem.tag and ('http://' in elem.text or 'https://' in elem.text):
        print(elem.text)
#-------------
import xml.etree.ElementTree as ET
import re

# Define a compiled regex pattern to match http, https, JDBC connections, and aexp
pattern = re.compile(r'(https?://|jdbc:|aexp)')

tree = ET.parse('flow.xml')
root = tree.getroot()

for elem in root.iter():
    # Check if elem.text contains any of our patterns
    if elem.text and pattern.search(elem.text):
        print(elem.text)
#-------------------
import xml.etree.ElementTree as ET
import re

# Define a compiled regex pattern to more specifically match endpoint connections
# This example includes patterns for typical URLs, JDBC connections, and your specified domains
pattern = re.compile(r'(https?://|jdbc:[\w:]+//)[\w.-]+(\.gso\.aexp\.com|\.aexp\.com)')

# Initialize a set to store unique matches
unique_endpoints = set()

tree = ET.parse('flow.xml')
root = tree.getroot()

for elem in root.iter():
    # Check if elem.text contains any of our specific endpoint connection patterns
    if elem.text and pattern.search(elem.text):
        # Add the match to the set of unique endpoints
        unique_endpoints.add(elem.text.strip())

# Print each unique endpoint connection found
for endpoint in unique_endpoints:
    print(endpoint)
#---------------------
import xml.etree.ElementTree as ET
import re

# Adjust the regex to capture the entire matching string for JDBC and HTTP(S) URLs
# Note: \S* matches any non-whitespace characters; adjust as needed for your specific patterns
pattern = re.compile(r'jdbc:[a-zA-Z]+://\S*?\.(gso\.aexp\.com|gso\.sexp\.com)\S*|https?://\S*?\.(gso\.aexp\.com|gso\.sexp\.com)\S*')

tree = ET.parse('flow.xml')
root = tree.getroot()

# Use a set to store unique matches to avoid duplicates
endpoints = set()

for elem in root.iter():
    if elem.text:
        # Find all matches within the text, no need to reconstruct from groups
        matches = pattern.findall(elem.text)
        # Add each match directly; we're interested in the whole matched string
        for match in matches:
            # Since findall might return a tuple due to multiple capture groups, join any non-empty strings from the tuple
            endpoint = ''.join(match) if isinstance(match, tuple) else match
            endpoints.add(endpoint)

# Print the unique, sorted list of endpoints
for endpoint in sorted(endpoints):
    print(endpoint)


